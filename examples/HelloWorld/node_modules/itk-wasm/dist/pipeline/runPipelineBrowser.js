import createWebWorkerPromise from '../core/internal/createWebWorkerPromise.js';
import loadEmscriptenModuleMainThread from '../core/internal/loadEmscriptenModuleMainThread.js';
import config from '../itkConfig.js';
import IOTypes from '../core/IOTypes.js';
import InterfaceTypes from '../core/InterfaceTypes.js';
import runPipelineEmscripten from './internal/runPipelineEmscripten.js';
import getTransferable from '../core/getTransferable.js';
// To cache loaded pipeline modules
const pipelineToModule = new Map();
async function loadPipelineModule(pipelinePath) {
    let moduleRelativePathOrURL = pipelinePath;
    let pipeline = pipelinePath;
    if (typeof pipelinePath !== 'string') {
        moduleRelativePathOrURL = new URL((pipelinePath).href);
        pipeline = moduleRelativePathOrURL.href;
    }
    if (pipelineToModule.has(pipeline)) {
        return pipelineToModule.get(pipeline);
    }
    else {
        const pipelineModule = await loadEmscriptenModuleMainThread(pipelinePath, config.pipelinesUrl);
        pipelineToModule.set(pipeline, pipelineModule);
        return pipelineModule;
    }
}
async function runPipelineBrowser(webWorker, pipelinePath, args, outputs, inputs) {
    if (webWorker === false) {
        const pipelineModule = await loadPipelineModule(pipelinePath.toString());
        const result = runPipelineEmscripten(pipelineModule, args, outputs, inputs);
        return result;
    }
    let worker = webWorker;
    const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise('pipeline', worker);
    worker = usedWorker;
    const transferables = [];
    if (!(inputs == null) && inputs.length > 0) {
        inputs.forEach(function (input) {
            if (input.type === InterfaceTypes.BinaryStream) {
                // Binary data
                const dataArray = input.data.data;
                const transferable = getTransferable(dataArray);
                if (transferable != null) {
                    transferables.push(transferable);
                }
            }
            else if (input.type === InterfaceTypes.BinaryFile) {
                // Binary data
                const dataArray = input.data.data;
                const transferable = getTransferable(dataArray);
                if (transferable != null) {
                    transferables.push(transferable);
                }
            }
            else if (input.type === InterfaceTypes.Image) {
                // Image data
                const image = input.data;
                if (image.data === null) {
                    throw Error('image data cannot be null');
                }
                let transferable = getTransferable(image.data);
                if (transferable != null) {
                    transferables.push(transferable);
                }
                transferable = getTransferable(image.direction);
                if (transferable != null) {
                    transferables.push(transferable);
                }
            }
            else if (input.type === IOTypes.Binary) {
                // Binary data
                const transferable = getTransferable(input.data);
                if (transferable != null) {
                    transferables.push(transferable);
                }
            }
            else if (input.type === IOTypes.Image) {
                // Image data
                const image = input.data;
                if (image.data === null) {
                    throw Error('image data cannot be null');
                }
                let transferable = getTransferable(image.data);
                if (transferable != null) {
                    transferables.push(transferable);
                }
                transferable = getTransferable(image.direction);
                if (transferable != null) {
                    transferables.push(transferable);
                }
            }
            else if (input.type === IOTypes.Mesh) {
                // Mesh data
                const mesh = input.data;
                if (mesh.points != null) {
                    const transferable = getTransferable(mesh.points);
                    if (transferable != null) {
                        transferables.push(transferable);
                    }
                }
                if (mesh.pointData != null) {
                    const transferable = getTransferable(mesh.pointData);
                    if (transferable != null) {
                        transferables.push(transferable);
                    }
                }
                if (mesh.cells != null) {
                    const transferable = getTransferable(mesh.cells);
                    if (transferable != null) {
                        transferables.push(transferable);
                    }
                }
                if (mesh.cellData != null) {
                    const transferable = getTransferable(mesh.cellData);
                    if (transferable != null) {
                        transferables.push(transferable);
                    }
                }
            }
        });
    }
    const result = await webworkerPromise.postMessage({
        operation: 'runPipeline',
        config: config,
        pipelinePath: pipelinePath.toString(),
        args,
        outputs,
        inputs
    }, transferables);
    return { returnValue: result.returnValue, stdout: result.stdout, stderr: result.stderr, outputs: result.outputs, webWorker: worker };
}
export default runPipelineBrowser;
