import path from 'path';
import mime from 'mime-types';
import mimeToIO from './internal/MimeToMeshIO.js';
import getFileExtension from './getFileExtension.js';
import extensionToIO from './internal/extensionToMeshIO.js';
import MeshIOIndex from './internal/MeshIOIndex.js';
import loadEmscriptenModule from '../core/internal/loadEmscriptenModuleNode.js';
import runPipelineEmscripten from '../pipeline/internal/runPipelineEmscripten.js';
import findLocalMeshIOPath from './internal/findLocalMeshIOPath.js';
import InterfaceTypes from '../core/InterfaceTypes.js';
/**
 * Write a mesh to a file on the local filesystem in Node.js.
 *
 * @param: mesh itk.Mesh instance to write
 * @param: filePath path to the file on the local filesystem.
 * @param: options.useCompression compression the pixel data when possible
 * @param: options.binaryFileType write in an binary as opposed to a ascii format, if
 * possible
 *
 * @return empty Promise
 */
async function writeMeshLocalFile(mesh, filePath, options) {
    if ('useCompression' in mesh || 'binaryFileType' in mesh) {
        throw new Error('options are now in the last argument position in itk-wasm');
    }
    const meshIOsPath = findLocalMeshIOPath();
    const absoluteFilePath = path.resolve(filePath);
    const mimeType = mime.lookup(absoluteFilePath);
    const extension = getFileExtension(absoluteFilePath);
    const args = ['0', absoluteFilePath, '--memory-io', '--quiet'];
    if ((options === null || options === void 0 ? void 0 : options.useCompression) === true) {
        args.push('--use-compression');
    }
    if ((options === null || options === void 0 ? void 0 : options.binaryFileType) === true) {
        args.push('--binary-file-type');
    }
    const desiredOutputs = [];
    const inputs = [
        { type: InterfaceTypes.Mesh, data: mesh }
    ];
    let io = null;
    if (mimeType !== false && mimeToIO.has(mimeType)) {
        io = mimeToIO.get(mimeType);
    }
    else if (extensionToIO.has(extension)) {
        io = extensionToIO.get(extension);
    }
    else {
        for (let idx = 0; idx < MeshIOIndex.length; ++idx) {
            const modulePath = path.join(meshIOsPath, MeshIOIndex[idx] + 'WriteMesh.js');
            const writeMeshModule = await loadEmscriptenModule(modulePath);
            const mountedFilePath = writeMeshModule.mountContainingDir(absoluteFilePath);
            const { returnValue } = runPipelineEmscripten(writeMeshModule, args, desiredOutputs, inputs);
            writeMeshModule.unmountContainingDir(mountedFilePath);
            if (returnValue === 0) {
                return null;
            }
        }
    }
    if (io === null) {
        throw Error('Could not find IO for: ' + absoluteFilePath);
    }
    const modulePath = path.join(meshIOsPath, io + 'WriteMesh.js');
    const writeMeshModule = await loadEmscriptenModule(modulePath);
    const mountedFilePath = writeMeshModule.mountContainingDir(absoluteFilePath);
    runPipelineEmscripten(writeMeshModule, args, desiredOutputs, inputs);
    writeMeshModule.unmountContainingDir(mountedFilePath);
    return null;
}
export default writeMeshLocalFile;
